---
title:  "쿠버네티스 인 액션 정리: Ch06 볼륨"
toc: true
toc_sticky: true
categories:
  - Docker
  - kubernetes
use_math: true
last_modified_at: 2023-03-28
---

## 개요

다루는 내용:
- 다중 컨테이너 파드를 생성하는 방법
- 컨테이너 간 디스크 스토리지를 공유하기 위해 볼륨을 생성하기
- 파드 내부에 깃 레포지토리 사용
- 파드에 GCE 퍼시스턴트 디스크와 같은 퍼시스턴트 스토리지 연결
- 사전 프로비저닝된 퍼시스턴트 스토리지
- 퍼시스턴트 스토리지의 동적 프로비저닝

- 여태까지 RC, RS, DS, Job service와 같은 파드와 상호작용하는 k8s 리소스를 살펴봄
- 이제는 파드 내부에서 컨테이너가 어떻게 외부 디스크에 접근하고 컨테이너 간 스토리지를 공유하는지 살펴볼 것임
- 파드는 논리적 호스트와 유사
  - 즉, 프로세스가 실행되며, CPU, RAM, 네트워크 인터페이스 등의 리소스를 공유
  - 그러나 디스크는 예외임
- 파일시스템은 컨테이너 이미지에서 제공되기 때문에 파드 내부의 각 컨테이너는 고유하게 분리된 파일시스템을 갖음
- 새로운 컨테이너가 시작할 때마다 컨테이너 이미지를 빌드할 때 추가한 파일을 갖은 채로 컨테이너가 구동
  - 컨테이너가 재시작될 수 있다는 점을 엮어서 생각해보면 새로 시작한 컨테이너는 이전에 실행한 컨테이너의 파일시스템과는 별개의 것이 됨
- k8s에서는 스토리지 볼륨을 통해 이전 컨테이너의 데이터 등을 유지할 수 있음
  - 스토리지 볼륨은 최상위 리소스는 아니지만 파드의 일부분으로 정의되며, 파드와 동일한 라이프 사이클을 갖음

## 1. 볼륨 (Volume)

- k8s 볼륨은 파드의 구성요소로, 컨테이너와 동일하게 파드 스펙에서 정의
- 볼륨은 독립적인 k8s 오브젝트가 아니므로 자체적으로 생성, 삭제될 수 없음
- 파드의 모든 컨테이너에서 사용 가능하나 컨테이너에서 각각 마운트해야 함
- 컨테이너에서 파일시스템의 어느 경로로나 볼륨을 마운트할 수 있음

### 1.1 예제 볼륨 설명

- 컨테이너 3개를 담고 있는 파드를 가정하자
  - WebServer: `/var/htdocs` 디렉터리에서 HTML 페이지를 서비스하고, `/var/logs`에 엑세스 로그를 저장 (웹 서버)
  - ContentAgent: `/var/html`에 HTML 파일을 생성하는 에이전트 실행 (콘텐츠 생성기)
  - LogRotator: `/var/logs` 디렉터리의 로그를 처리
- 각 컨테이너는 잘 정의된 단일 책임을 갖으나 각 컨테이너 자체만으로는 의미가 없음
  - ContentAgent가 생성한 HTML 파일을 자체 컨테이너에 저장하고, 웹 서버는 이에 접근할 수가 없기 때문
- 따라서 볼륨 2개를 파드에 추가하고, 세 개의 컨테이너 내부의 적절한 경로에 마운트해서 더 나은 구성을 짤 수 있음
  - publicHTML: WebServer와 ContentAgent에 마운트. WebServer의 `/var/htdocs`의 파일을 서비스, ContentAgent의 `/var/html`에 생성된 파일을 해당 경로에 쓴다. 이런 방식으로 마운트하면 콘텐츠 생성기가 작성한 내용을 웹 서버가 서비스할 수 있다
  - logVol: WebServer와 LogRotator의 `/var/logs`에 마운트.
- 컨테이너에서 접근하려면 파드에서 볼륨을 정의하는 것 뿐만 아니라 VolumeMount를 컨테이너 스펙에 정의해야 함
- 이 예제의 두 볼륨은 빈 상태로 초기화되므로 emptyDir 유형의 볼륨 사용 가능
- k8s는 볼륨을 초기화하며 외부 소스의 내용을 채우거나 볼륨 내부에 기존에 존재하는 디렉터리를 마운트하는 등 여러 유형의 볼륨 지원
- 볼륨을 채우거나 마운트하는 프로세스는 파드의 컨테이너가 시작되기 전에 수행
- 볼륨이 파드의 라이브사이클에 바인딩되면 파드가 존재하는 동안 유지도지만 볼륨 유형에 따라 파드와 볼륨이 사라진 후에도 볼륨의 파일이 유지되어 새로운 볼륨으로 마운트 할 수 있다

### 1.2 볼륨 유형

- `emptyDir`: 일시적인 데이터 저장하는데 사용되는 간단한 빈 디렉터리
- `hostPath`: 워커 노드의 파일시스템을 파드의 디렉터리로 마운트
- `gitRepo`: 깃 레포지터리의 콘텐츠를 체크아웃해 초기화한 볼륨
- `nfs`: *NFS* 공유를 파드에 마운트
- `gcePersistentDisk`, `awsElasticBlockStore`, `azureDisk`: 클라우드 제공자의 전용 스토리지를 마운트
- `cinder`, `cephfs`, `iscsi`, `flocker`, `glusterfs`, `quobyte`, `rbd`, `flexVolume`, `vsphereVolume`, `photonPersistentDisk`, `ScaleIO`: 다른 유형의 네트워크 스토리지를 마운트하는데 사용
- `configMap`, `secret`, `downwaredAPI`: k8s 리소스나 클러스터 정보를 파드에 노출하는 데 사용하는 특수한 유형 (데이터 저장하는데 사용 X. k8s 메타데이터를 파드에 실행 중인 애플리케이션에 노출하는데 사용)
- `persistentVolumeClaim`: 사전에 혹은 동적으로 프로비저닝된 퍼시스턴트 스토리지

> NFS(Network File System)는 네트워크에 파일을 저장하는 메커니즘입니다. 이 시스템은 사용자가 원격 컴퓨터에 있는 파일 및 디렉토리에 액세스할 수 있고 해당 파일 및 디렉토리가 로컬에 있는 것처럼 처리하도록 허용하는 분산 파일 시스템입니다.

## 2. 볼륨을 사용하여 컨테이너 간 데이터 공유하기

### 2.1 emptyDir 볼륨 사용

- 가장 간단한 유형으로 그냥 빈 디렉터리임
- emptyDir 볼륨은 동일 파드에서 실행 중인 컨테이너 간 파일 공유하는데 사용
- 단일 컨테이너에서 메모리에 넣기에는 큰 데이터의 정렬과 같이 임시 데이터를 디스크에 쓰는 목적으로도 사용함

파드에 emptyDir 볼륨 사용
- 환경 세팅:
  - 앞서 본 예제에서 하나의 볼륨을 통해 파드를 구성한다고 가정
  - Nginx를 웹 서버로 사용
  - 유닉스 fortune 명령으로 HTML 콘텐츠를 생성
  - fortune 명령은 실행할 때마다 임의의 인용문 출력
  - 매 10초마다 fortune 명령을 실행하고 출력을 `index.html`에 저장하는 스크립트 생성 (`fortuneloop.sh`)

TODO: 파드 생성 매니페스트

- 파드는 컨테이너 두개와 하나의 볼륨을 갖음
- html-generator가 시작하면 매 10초마다 fortune 명령의 결과를 `/var/htdocs/index.html`에 write
- 볼륨이 `/var/htdocs/`에 마운트되었으므로 index.html 파일은 컨테이너 최상단 레이어가 아닌 볼륨에 쓰여짐
- web-server 컨테이너가 시작하면 `/usr/share/nginx/html` 디렉터리(nginx 서버가 서비스하는 디폴트 디렉터리)의 HTML 파일을 서비스
- Nginx는 fortune 루프를 실행하는 컨테이너가 작성한 index.html파일을 서비스
- 클라이언트가 파드의 포트 80으로 보낸 HTTP 요청은 fortune 메시지를 응답으로 받음

실행 중인 파드 보기
- fortune 메시지를 보려면 파드의 접근을 활성화해야 함
  - 포트를 파드로 포워딩하거나 서비스로 파드를 노출

emptyDir을 사용하기 위한 매체 지정
- emptyDir은 파드를 호스팅하는 워커 노드의 실제 디스크에 생성되므로 노드 디스크의 유형에 따라 성능 결정
- emptyDir을 디스크가 아닌 메모리를 사용하는 *tmpfs 파일시스템*으로 생성할 수 있음
  - tmpfs: 메모리를 파일처럼 사용할 수 있게 함

TODO: 메니페스트 (p. 268)



### 2.2 깃 레포지토리 볼륨 사용

> 경고: gitRepo 볼륨 유형은 사용 중단되었다. git repo가 있는 컨테이너를 프로비전 하려면 초기화 컨테이너(InitContainer)에 EmptyDir을 마운트하고, 여기에 git을 사용해서 repo를 복제하고, EmptyDir을 파드 컨테이너에 마운트 한다.

예제: https://nearhome.tistory.com/99

TODO: 되는지 확인하고, 안되면 되는 방법 찾기

## 3. 워커 노드 파일시스템의 파일 접근

- 대부분의 파드는 호스트 노드를 인식하지 못함
  - 따라서 노드의 파일시스템에 있는 파일에 접근해선 안 됨
- 특정 시스템 레벨의 파드(보통 DS로 관리)는 노드의 파일을 읽거나 파일시스템을 통해 노드 디바이스에 접근
- 이는 hostpath 볼륨으로 가능

### 3.1 hostPath 볼륨

- 노드 파일시스템의 특정 파일이나 디렉터리를 의미
- 퍼시스턴트 스토리티 유형으로, 파드가 삭제 혹은 재기동되면 호스트의 동일 경로를 가리키는 hostPath 볼륨을 사용
- 단 DB의 데이터 디렉터리 저장용으로는 불가능
  - 특정 노드의 파일시스템에 저장
  - 다른 노드로 스케줄링되면 데이터 접근이 안 됨
  - 어떤 노드에 스케줄링 되는지에 민감함

### 3.2 hostPath 볼륨을 사용하는 시스템 파드 검사

- 여러 개의 시스템 파드가 kube-system 네임스페이스에서 실행 중이므로 이를 살펴보자

```sh
kubectl get pod s --namespace kube-system
```

